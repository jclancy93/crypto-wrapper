{"ast":null,"code":"var _s = $RefreshSig$();\n\nimport { useCallback, useEffect, useState } from 'react';\nimport { ethers } from 'ethers';\nimport { useNxmContract } from './useContract';\nimport { useActiveWeb3React } from './index';\nimport { NETWORK_WNXM_CONTRACT_ADDRESS, NXM_TOKEN_DECIMALS } from '../constants';\nconst {\n  BigNumber\n} = ethers;\nexport const useNxm = () => {\n  _s();\n\n  const {\n    account,\n    chainId\n  } = useActiveWeb3React();\n  const nxmContract = useNxmContract();\n  const [allowance, setAllowance] = useState(BigNumber.from(0));\n  const [balance, setBalance] = useState({\n    rawBalance: 0,\n    parsedBalance: 0.0,\n    displayBalance: '--'\n  });\n  const [isWhitelisted, setWhitelisted] = useState(false);\n  const fetchAllowance = useCallback(async () => {\n    if (account) {\n      try {\n        const allowance = await (nxmContract === null || nxmContract === void 0 ? void 0 : nxmContract.allowance(account, NETWORK_WNXM_CONTRACT_ADDRESS[chainId]));\n        setAllowance(BigNumber.from(allowance));\n      } catch (err) {\n        setAllowance(BigNumber.from(0));\n      }\n    }\n  }, [account, nxmContract]);\n  const fetchWhitelisted = useCallback(async () => {\n    if (account) {\n      try {\n        const whitelisted = await nxmContract.whiteListed(account);\n        setWhitelisted(whitelisted);\n      } catch (err) {\n        setWhitelisted(false);\n      }\n    }\n  });\n  const fetchBalance = useCallback(async () => {\n    if (account) {\n      try {\n        const balance = await nxmContract.balanceOf(account);\n        setBalance({\n          rawBalance: balance,\n          parsedBalance: ethers.utils.formatUnits(balance),\n          displayBalance: (+ethers.utils.formatUnits(balance)).toFixed(6)\n        });\n      } catch (err) {\n        setBalance({\n          rawBalance: 0,\n          parsedBalance: 0.0,\n          displayBalance: '--'\n        });\n      }\n    }\n  });\n  useEffect(() => {\n    if (account && nxmContract) {\n      fetchAllowance();\n      fetchWhitelisted();\n      fetchBalance();\n    }\n\n    const refreshInterval = setInterval(fetchAllowance, 10000);\n    return () => clearInterval(refreshInterval);\n  }, [account, nxmContract, fetchAllowance]);\n  const approve = useCallback(async () => {\n    try {\n      const tx = await nxmContract.approve(NETWORK_WNXM_CONTRACT_ADDRESS[chainId], ethers.constants.MaxUint256.toString());\n      return tx;\n    } catch (err) {\n      throw err;\n    }\n  });\n  return {\n    allowance,\n    balance,\n    isWhitelisted,\n    approve\n  };\n};\n\n_s(useNxm, \"AZ8TS02qNVvNpcQzVQ2qLUUNGLc=\", false, function () {\n  return [useActiveWeb3React, useNxmContract];\n});","map":{"version":3,"sources":["/Users/jackclancy/Desktop/apps/nexus-wrapper/packages/react-app/src/hooks/useNxm.js"],"names":["useCallback","useEffect","useState","ethers","useNxmContract","useActiveWeb3React","NETWORK_WNXM_CONTRACT_ADDRESS","NXM_TOKEN_DECIMALS","BigNumber","useNxm","account","chainId","nxmContract","allowance","setAllowance","from","balance","setBalance","rawBalance","parsedBalance","displayBalance","isWhitelisted","setWhitelisted","fetchAllowance","err","fetchWhitelisted","whitelisted","whiteListed","fetchBalance","balanceOf","utils","formatUnits","toFixed","refreshInterval","setInterval","clearInterval","approve","tx","constants","MaxUint256","toString"],"mappings":"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","sourcesContent":["import { useCallback, useEffect, useState } from 'react'\nimport { ethers } from 'ethers'\nimport { useNxmContract } from './useContract'\nimport { useActiveWeb3React } from './index'\nimport { \n  NETWORK_WNXM_CONTRACT_ADDRESS,\n  NXM_TOKEN_DECIMALS\n} from '../constants'\n\nconst { BigNumber } = ethers\n\nexport const useNxm = () => {\n  const { account, chainId } = useActiveWeb3React()\n  const nxmContract = useNxmContract()\n\n  const [allowance, setAllowance] = useState(BigNumber.from(0))\n  const [balance, setBalance] = useState({ \n    rawBalance: 0,\n    parsedBalance: 0.0,\n    displayBalance: '--',\n   })\n  const [isWhitelisted, setWhitelisted] = useState(false)\n\n  const fetchAllowance = useCallback(async () => {\n    if (account) {\n      try {\n        const allowance = await nxmContract?.allowance(\n          account,\n          NETWORK_WNXM_CONTRACT_ADDRESS[chainId]\n        )\n        setAllowance(BigNumber.from(allowance))\n      } catch(err) {\n        setAllowance(BigNumber.from(0))\n      }\n    }\n  }, [account, nxmContract])\n\n  const fetchWhitelisted = useCallback(async () => {\n    if (account) {\n      try {\n        const whitelisted = await nxmContract.whiteListed(account)\n        setWhitelisted(whitelisted)\n      } catch(err) {\n        setWhitelisted(false)\n      }\n    }\n  })\n\n  const fetchBalance = useCallback(async () => {\n    if (account) {\n      try {\n        const balance = await nxmContract.balanceOf(account)\n        setBalance({\n          rawBalance: balance,\n          parsedBalance: ethers.utils.formatUnits(balance),\n          displayBalance: (+ethers.utils.formatUnits(balance)).toFixed(6),\n        })\n      } catch (err) {\n        setBalance({\n          rawBalance: 0,\n          parsedBalance: 0.0,\n          displayBalance: '--',\n        })\n      }\n    }\n  })\n\n  useEffect(() => {\n    if (account && nxmContract) {\n      fetchAllowance()\n      fetchWhitelisted()\n      fetchBalance()\n    }\n    const refreshInterval = setInterval(fetchAllowance, 10000)\n    return () => clearInterval(refreshInterval)\n  }, [account, nxmContract, fetchAllowance])\n\n  const approve = useCallback(async () => {\n    try {\n      const tx = await nxmContract.approve(\n        NETWORK_WNXM_CONTRACT_ADDRESS[chainId],\n        ethers.constants.MaxUint256.toString()\n      )\n      return tx\n    } catch (err) {\n      throw err\n    }\n  })\n\n  return { allowance, balance, isWhitelisted, approve }\n}"]},"metadata":{},"sourceType":"module"}